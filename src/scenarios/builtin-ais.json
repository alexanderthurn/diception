[
    {
        "name": "Easy",
        "description": "Simple AI that attacks when it has equal or more dice",
        "prompt": "",
        "code": "// Easy AI: Attacks when dice advantage >= 0\nconst myTiles = api.getMyTiles().filter(t => t.dice > 1);\n\nfor (const tile of myTiles) {\n    const neighbors = api.getAdjacentTiles(tile.x, tile.y);\n    for (const target of neighbors) {\n        if (target.owner !== api.myId && tile.dice >= target.dice) {\n            api.attack(tile.x, tile.y, target.x, target.y);\n        }\n    }\n}\n\napi.endTurn();"
    },
    {
        "name": "Medium",
        "description": "Tries to connect its territory to gain more dice",
        "prompt": "",
        "code": "// Medium AI: Prioritizes moves that increase connected region size\nconst moves = [];\nconst myTiles = api.getMyTiles().filter(t => t.dice > 1);\n\nfor (const tile of myTiles) {\n    const neighbors = api.getAdjacentTiles(tile.x, tile.y);\n    for (const target of neighbors) {\n        if (target.owner !== api.myId && tile.dice > target.dice) {\n            \n            // Simulate to see if this improves our connected region\n            const sim = api.simulateAttack(tile.x, tile.y, target.x, target.y);\n            \n            // Score based primarily on predicted reinforcements\n            let score = sim.myPredictedReinforcements;\n            \n            // Tie-breaker: efficiency (dice difference) logic to prefer safer wins\n            const diff = tile.dice - target.dice;\n            score += diff * 0.1;\n\n            moves.push({ from: tile, to: target, score });\n        }\n    }\n}\n\n// Sort: Highest reinforcements first\nmoves.sort((a, b) => b.score - a.score);\n\n// Execute\nfor (const move of moves) {\n    const t = api.getTileAt(move.from.x, move.from.y);\n    const target = api.getTileAt(move.to.x, move.to.y);\n    \n    // Validation before execution\n    if (t && target && t.owner === api.myId && t.dice > target.dice && target.owner !== api.myId) {\n        api.attack(move.from.x, move.from.y, move.to.x, move.to.y);\n    }\n}\napi.endTurn();"
    },
    {
        "name": "Hard",
        "description": "Advanced AI that maximizes territory efficiently and cuts enemy supply lines",
        "prompt": "",
        "code": "// Hard AI: Smart Connector - Prioritizes efficiency and cutting enemies\nconst moves = [];\nconst myTiles = api.getMyTiles().filter(t => t.dice > 1);\n\n// Cache current stats to detect \"cuts\"\nconst enemyStats = {};\nconst players = api.players;\nfor (const p of players) {\n    if (p.id !== api.myId && p.alive) {\n        enemyStats[p.id] = api.getReinforcements(p.id);\n    }\n}\n\nfor (const tile of myTiles) {\n    const neighbors = api.getAdjacentTiles(tile.x, tile.y);\n    for (const target of neighbors) {\n        if (target.owner !== api.myId && tile.dice > target.dice) {\n            \n            const sim = api.simulateAttack(tile.x, tile.y, target.x, target.y);\n            \n            // 1. Base Score: Territory connectivity\n            let score = sim.myPredictedReinforcements * 10; \n\n            // 2. Efficiency Bonus (+2 dice diff is strong reason)\n            const diff = tile.dice - target.dice;\n            if (diff >= 2) {\n                score += 20; // Equivalent to gaining +2 territory blocks roughly in weight\n            } else {\n                // Risky attack (diff == 1)\n                // Only do it if strategic gain is huge\n                score -= 5; \n            }\n\n            // 3. Cutting Bonus (Destroying enemy connectivity)\n            if (target.owner !== null && sim.enemyPredictedReinforcements < (enemyStats[target.owner] || 0)) {\n                const cutAmount = (enemyStats[target.owner] || 0) - sim.enemyPredictedReinforcements;\n                score += cutAmount * 15; // Cutting is very valuable\n            }\n\n            moves.push({ from: tile, to: target, score });\n        }\n    }\n}\n\n// Sort best moves first\nmoves.sort((a, b) => b.score - a.score);\n\n// Execute\nfor (const move of moves) {\n    const t = api.getTileAt(move.from.x, move.from.y);\n    const target = api.getTileAt(move.to.x, move.to.y);\n    \n    if (t && target && t.owner === api.myId && t.dice > target.dice && target.owner !== api.myId) {\n        api.attack(move.from.x, move.from.y, move.to.x, move.to.y);\n    }\n}\napi.endTurn();"
    },
    {
        "name": "Adaptive",
        "description": "Learning AI that adapts its strategy based on past games",
        "prompt": "",
        "code": "// Adaptive AI: Learns and adapts strategy\n\n// Load past performance\nlet stats = api.load('stats') || { wins: 0, losses: 0, aggression: 0.5 };\nlet gameStats = api.load('currentGame') || { attacks: 0, wins: 0, territory: 0 };\n\n// Adjust aggression based on past performance\nconst winRate = stats.wins / Math.max(1, stats.wins + stats.losses);\nconst aggression = stats.aggression;\n\nfunction evaluateMove(from, to) {\n    const diff = from.dice - to.dice;\n    const winProb = api.getWinProbability(from.dice, to.dice, api.diceSides);\n    \n    // Threshold based on aggression level\n    const threshold = 0.6 - aggression * 0.3; // 0.3 to 0.6\n    \n    if (winProb < threshold) return -1;\n    \n    let score = winProb * 100;\n    score += diff * 10;\n    \n    // Full stacks must attack\n    if (from.dice === api.maxDice) score += 50;\n    \n    // Easy kills\n    if (to.dice === 1) score += 30 * aggression;\n    \n    // Territory expansion\n    const neighbors = api.getAdjacentTiles(to.x, to.y);\n    const enemyNeighbors = neighbors.filter(n => n.owner !== api.myId).length;\n    score += enemyNeighbors * 10 * aggression;\n    \n    return score;\n}\n\n// Collect moves\nconst moves = [];\nconst myTiles = api.getMyTiles();\nconst attackers = myTiles.filter(t => t.dice > 1);\n\nfor (const tile of attackers) {\n    const neighbors = api.getAdjacentTiles(tile.x, tile.y);\n    for (const target of neighbors) {\n        if (target.owner !== api.myId) {\n            const score = evaluateMove(tile, target);\n            if (score > 0) {\n                moves.push({ from: tile, to: target, score });\n            }\n        }\n    }\n}\n\nmoves.sort((a, b) => b.score - a.score);\n\n// Execute with move limit based on aggression\nconst maxAttacks = Math.floor(5 + aggression * 20);\nlet attackCount = 0;\n\nfor (const move of moves) {\n    if (attackCount >= maxAttacks) break;\n    \n    const currentTile = api.getTileAt(move.from.x, move.from.y);\n    if (currentTile && currentTile.dice > 1 && currentTile.owner === api.myId) {\n        const result = api.attack(move.from.x, move.from.y, move.to.x, move.to.y);\n        if (result.success) {\n            gameStats.attacks++;\n            if (result.expectedWin) gameStats.wins++;\n            attackCount++;\n        }\n    }\n}\n\n// Track territory for learning\nconst currentTerritory = api.getMyTiles().length;\nif (gameStats.territory === 0) {\n    gameStats.territory = currentTerritory;\n} else {\n    // Adjust aggression based on territory change\n    if (currentTerritory > gameStats.territory) {\n        stats.aggression = Math.min(1, stats.aggression + 0.02);\n    } else if (currentTerritory < gameStats.territory) {\n        stats.aggression = Math.max(0.1, stats.aggression - 0.01);\n    }\n    gameStats.territory = currentTerritory;\n}\n\n// Save state\napi.save('stats', stats);\napi.save('currentGame', gameStats);\n\napi.endTurn();"
    }
]