[
    {
        "name": "Easy",
        "description": "Simple AI that prefers attacking weak neighbors and maintains basic aggression.",
        "prompt": "",
        "code": "return class EasyAI {\n  async endTurn(api) {\n    const allMyTiles = api.getMyTiles();\n    const minAttacks = Math.ceil(allMyTiles.length * 0.2);\n    let attacksDone = 0;\n    let safety = 0;\n\n    while (attacksDone < 200 && safety < 500) {\n      safety++;\n      const attackers = api.getMyTiles().filter(t => t.dice > 1);\n      const moves = [];\n      \n      for (const tile of attackers) {\n        const neighbors = api.getAdjacentTiles(tile.x, tile.y);\n        for (const target of neighbors) {\n          if (target.owner !== api.myId) {\n            const winProb = api.getWinProbability(tile.dice, target.dice);\n            const score = -target.dice + (winProb * 0.5);\n            moves.push({ from: tile, to: target, score, winProb });\n          }\n        }\n      }\n\n      if (moves.length === 0) break;\n      moves.sort((a, b) => b.score - a.score);\n      \n      const move = moves[0];\n      if (attacksDone < minAttacks || move.winProb > 0.5) {\n        const res = api.attack(move.from.x, move.from.y, move.to.x, move.to.y);\n        if (res.success) {\n          attacksDone++;\n        } else {\n          break; // Stop if API rejects (e.g. move limit)\n        }\n      } else {\n        break; // Above quota and no good moves left\n      }\n    }\n  }\n}"
    },
    {
        "name": "Medium",
        "description": "Balanced AI that targets strong neighbors to disrupt enemies.",
        "prompt": "",
        "code": "return class MediumAI {\n  async endTurn(api) {\n    const allMyTiles = api.getMyTiles();\n    const minAttacks = Math.ceil(allMyTiles.length * 0.2);\n    let attacksDone = 0;\n    let safety = 0;\n\n    while (attacksDone < 200 && safety < 500) {\n      safety++;\n      const attackers = api.getMyTiles().filter(t => t.dice > 1);\n      const moves = [];\n\n      for (const tile of attackers) {\n        const neighbors = api.getAdjacentTiles(tile.x, tile.y);\n        for (const target of neighbors) {\n          if (target.owner !== api.myId) {\n            const winProb = api.getWinProbability(tile.dice, target.dice);\n            const score = target.dice + (winProb * 2);\n            moves.push({ from: tile, to: target, score, winProb });\n          }\n        }\n      }\n\n      if (moves.length === 0) break;\n      moves.sort((a, b) => b.score - a.score);\n\n      const move = moves[0];\n      if (attacksDone < minAttacks || move.winProb > 0.6) {\n        const res = api.attack(move.from.x, move.from.y, move.to.x, move.to.y);\n        if (res.success) {\n          attacksDone++;\n        } else {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n  }\n}"
    },
    {
        "name": "Hard",
        "description": "Selection AI that targets powerful neighbors but only with high confidence.",
        "prompt": "",
        "code": "return class HardAI {\n  async endTurn(api) {\n    const allMyTiles = api.getMyTiles();\n    const minAttacks = Math.ceil(allMyTiles.length * 0.2);\n    let attacksDone = 0;\n    let safety = 0;\n\n    while (attacksDone < 200 && safety < 500) {\n      safety++;\n      const attackers = api.getMyTiles().filter(t => t.dice > 1);\n      const moves = [];\n\n      for (const tile of attackers) {\n        const neighbors = api.getAdjacentTiles(tile.x, tile.y);\n        for (const target of neighbors) {\n          if (target.owner !== api.myId) {\n            const winProb = api.getWinProbability(tile.dice, target.dice);\n            const score = (target.dice * 5) * winProb;\n            moves.push({ from: tile, to: target, score, winProb });\n          }\n        }\n      }\n\n      if (moves.length === 0) break;\n      moves.sort((a, b) => b.score - a.score);\n\n      const move = moves[0];\n      if (attacksDone < minAttacks || move.winProb > 0.8) {\n        const res = api.attack(move.from.x, move.from.y, move.to.x, move.to.y);\n        if (res.success) {\n          attacksDone++;\n        } else {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n  }\n}"
    }
]