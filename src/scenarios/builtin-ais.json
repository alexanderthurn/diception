[
    {
        "name": "Easy",
        "description": "Simple AI that prefers attacking weak neighbors and maintains basic aggression.",
        "prompt": "",
        "code": "return class EasyAI {\n  async endTurn(api) {\n    const allMyTiles = api.getMyTiles();\n    const minAttacks = Math.ceil(allMyTiles.length * 0.2);\n    let attacksDone = 0;\n    let safety = 0;\n\n    while (attacksDone < 200 && safety < 500) {\n      safety++;\n      const attackers = api.getMyTiles().filter(t => t.dice > 1);\n      const moves = [];\n      \n      for (const tile of attackers) {\n        const neighbors = api.getAdjacentTiles(tile.x, tile.y);\n        for (const target of neighbors) {\n          if (target.owner !== api.myId) {\n            const winProb = api.getWinProbability(tile.dice, target.dice);\n            const score = -target.dice + (winProb * 0.5);\n            moves.push({ from: tile, to: target, score, winProb });\n          }\n        }\n      }\n\n      if (moves.length === 0) break;\n      moves.sort((a, b) => b.score - a.score);\n      \n      const move = moves[0];\n      if (attacksDone < minAttacks || move.winProb > 0.5) {\n        const res = api.attack(move.from.x, move.from.y, move.to.x, move.to.y);\n        if (res.success) {\n          attacksDone++;\n        } else {\n          break; // Stop if API rejects (e.g. move limit)\n        }\n      } else {\n        break; // Above quota and no good moves left\n      }\n    }\n  }\n}"
    },
    {
        "name": "Medium",
        "description": "Balanced AI that targets strong neighbors to disrupt enemies.",
        "prompt": "",
        "code": "return class MediumAI {\n  async endTurn(api) {\n    const allMyTiles = api.getMyTiles();\n    const minAttacks = Math.ceil(allMyTiles.length * 0.2);\n    let attacksDone = 0;\n    let safety = 0;\n\n    while (attacksDone < 200 && safety < 500) {\n      safety++;\n      const attackers = api.getMyTiles().filter(t => t.dice > 1);\n      const moves = [];\n\n      for (const tile of attackers) {\n        const neighbors = api.getAdjacentTiles(tile.x, tile.y);\n        for (const target of neighbors) {\n          if (target.owner !== api.myId) {\n            const winProb = api.getWinProbability(tile.dice, target.dice);\n            const score = target.dice + (winProb * 2);\n            moves.push({ from: tile, to: target, score, winProb });\n          }\n        }\n      }\n\n      if (moves.length === 0) break;\n      moves.sort((a, b) => b.score - a.score);\n\n      const move = moves[0];\n      if (attacksDone < minAttacks || move.winProb > 0.6) {\n        const res = api.attack(move.from.x, move.from.y, move.to.x, move.to.y);\n        if (res.success) {\n          attacksDone++;\n        } else {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n  }\n}"
    },
    {
        "name": "Hard",
        "description": "Selection AI that targets powerful neighbors but only with high confidence.",
        "prompt": "",
        "code": "return class HardAI {\n  async endTurn(api) {\n    const allMyTiles = api.getMyTiles();\n    const minAttacks = Math.ceil(allMyTiles.length * 0.2);\n    let attacksDone = 0;\n    let safety = 0;\n\n    while (attacksDone < 200 && safety < 500) {\n      safety++;\n      const attackers = api.getMyTiles().filter(t => t.dice > 1);\n      const moves = [];\n\n      for (const tile of attackers) {\n        const neighbors = api.getAdjacentTiles(tile.x, tile.y);\n        for (const target of neighbors) {\n          if (target.owner !== api.myId) {\n            const winProb = api.getWinProbability(tile.dice, target.dice);\n            const score = (target.dice * 5) * winProb;\n            moves.push({ from: tile, to: target, score, winProb });\n          }\n        }\n      }\n\n      if (moves.length === 0) break;\n      moves.sort((a, b) => b.score - a.score);\n\n      const move = moves[0];\n      if (attacksDone < minAttacks || move.winProb > 0.8) {\n        const res = api.attack(move.from.x, move.from.y, move.to.x, move.to.y);\n        if (res.success) {\n          attacksDone++;\n        } else {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n  }\n}"
    },
    {
        "name": "Adaptive",
        "description": "Learning AI that adapts its strategy based on past games",
        "prompt": "",
        "code": "return class AdaptiveAI {\n  async init(api) {\n    this.stats = api.load('stats') || { wins: 0, losses: 0, aggression: 0.5 };\n  }\n  async endTurn(api) {\n    let gameStats = api.load('currentGame') || { attacks: 0, wins: 0, territory: 0 };\n    const aggression = this.stats.aggression;\n    const evaluateMove = (from, to) => {\n        const diff = from.dice - to.dice;\n        const winProb = api.getWinProbability(from.dice, to.dice, api.diceSides);\n        const threshold = 0.6 - aggression * 0.3;\n        if (winProb < threshold) return -1;\n        let score = winProb * 100 + diff * 10;\n        if (from.dice === api.maxDice) score += 50;\n        if (to.dice === 1) score += 30 * aggression;\n        const neighbors = api.getAdjacentTiles(to.x, to.y);\n        const enemyNeighbors = neighbors.filter(n => n.owner !== api.myId).length;\n        score += enemyNeighbors * 10 * aggression;\n        return score;\n    };\n    const moves = [];\n    const attackers = api.getMyTiles().filter(t => t.dice > 1);\n    for (const tile of attackers) {\n        const neighbors = api.getAdjacentTiles(tile.x, tile.y);\n        for (const target of neighbors) {\n            if (target.owner !== api.myId) {\n                const score = evaluateMove(tile, target);\n                if (score > 0) moves.push({ from: tile, to: target, score });\n            }\n        }\n    }\n    moves.sort((a, b) => b.score - a.score);\n    const maxAttacks = Math.floor(5 + aggression * 20);\n    let attackCount = 0;\n    for (const move of moves) {\n        if (attackCount >= maxAttacks) break;\n        const currentTile = api.getTileAt(move.from.x, move.from.y);\n        if (currentTile && currentTile.dice > 1 && currentTile.owner === api.myId) {\n            const result = api.attack(move.from.x, move.from.y, move.to.x, move.to.y);\n            if (result.success) {\n                gameStats.attacks++;\n                if (result.expectedWin) gameStats.wins++;\n                attackCount++;\n            }\n        }\n    }\n    const currentTerritory = api.getMyTiles().length;\n    if (gameStats.territory === 0) gameStats.territory = currentTerritory;\n    else {\n        if (currentTerritory > gameStats.territory) this.stats.aggression = Math.min(1, this.stats.aggression + 0.02);\n        else if (currentTerritory < gameStats.territory) this.stats.aggression = Math.max(0.1, this.stats.aggression - 0.01);\n        gameStats.territory = currentTerritory;\n    }\n    api.save('stats', this.stats);\n    api.save('currentGame', gameStats);\n  }\n}"
    }
]