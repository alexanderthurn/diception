[
    {
        "name": "Easy",
        "description": "Simple AI that attacks when it has equal or more dice",
        "prompt": "",
        "code": "return class EasyAI {\n  async endTurn(api) {\n    const myTiles = api.getMyTiles().filter(t => t.dice > 1);\n    for (const tile of myTiles) {\n        const neighbors = api.getAdjacentTiles(tile.x, tile.y);\n        for (const target of neighbors) {\n            if (target.owner !== api.myId && tile.dice >= target.dice) {\n                api.attack(tile.x, tile.y, target.x, target.y);\n            }\n        }\n    }\n  }\n}"
    },
    {
        "name": "Medium",
        "description": "Tries to connect its territory to gain more dice",
        "prompt": "",
        "code": "return class MediumAI {\n  async endTurn(api) {\n    const moves = [];\n    const myTiles = api.getMyTiles().filter(t => t.dice > 1);\n    for (const tile of myTiles) {\n        const neighbors = api.getAdjacentTiles(tile.x, tile.y);\n        for (const target of neighbors) {\n            if (target.owner !== api.myId && tile.dice > target.dice) {\n                const sim = api.simulateAttack(tile.x, tile.y, target.x, target.y);\n                let score = sim.myPredictedReinforcements;\n                const diff = tile.dice - target.dice;\n                score += diff * 0.1;\n                moves.push({ from: tile, to: target, score });\n            }\n        }\n    }\n    moves.sort((a, b) => b.score - a.score);\n    for (const move of moves) {\n        const t = api.getTileAt(move.from.x, move.from.y);\n        const target = api.getTileAt(move.to.x, move.to.y);\n        if (t && target && t.owner === api.myId && t.dice > target.dice && target.owner !== api.myId) {\n            api.attack(move.from.x, move.from.y, move.to.x, move.to.y);\n        }\n    }\n  }\n}"
    },
    {
        "name": "Hard",
        "description": "Advanced AI that maximizes territory efficiently and cuts enemy supply lines",
        "prompt": "",
        "code": "return class HardAI {\n  async endTurn(api) {\n    const moves = [];\n    const myTiles = api.getMyTiles().filter(t => t.dice > 1);\n    const enemyStats = {};\n    for (const p of api.players) {\n        if (p.id !== api.myId && p.alive) {\n            enemyStats[p.id] = api.getReinforcements(p.id);\n        }\n    }\n    for (const tile of myTiles) {\n        const neighbors = api.getAdjacentTiles(tile.x, tile.y);\n        for (const target of neighbors) {\n            if (target.owner !== api.myId && tile.dice > target.dice) {\n                const sim = api.simulateAttack(tile.x, tile.y, target.x, target.y);\n                let score = sim.myPredictedReinforcements * 10;\n                const diff = tile.dice - target.dice;\n                if (diff >= 2) score += 20;\n                else score -= 5;\n                if (target.owner !== null && sim.enemyPredictedReinforcements < (enemyStats[target.owner] || 0)) {\n                    const cutAmount = (enemyStats[target.owner] || 0) - sim.enemyPredictedReinforcements;\n                    score += cutAmount * 15;\n                }\n                moves.push({ from: tile, to: target, score });\n            }\n        }\n    }\n    moves.sort((a, b) => b.score - a.score);\n    for (const move of moves) {\n        const t = api.getTileAt(move.from.x, move.from.y);\n        const target = api.getTileAt(move.to.x, move.to.y);\n        if (t && target && t.owner === api.myId && t.dice > target.dice && target.owner !== api.myId) {\n            api.attack(move.from.x, move.from.y, move.to.x, move.to.y);\n        }\n    }\n  }\n}"
    },
    {
        "name": "Adaptive",
        "description": "Learning AI that adapts its strategy based on past games",
        "prompt": "",
        "code": "return class AdaptiveAI {\n  async init(api) {\n    this.stats = api.load('stats') || { wins: 0, losses: 0, aggression: 0.5 };\n  }\n  async endTurn(api) {\n    let gameStats = api.load('currentGame') || { attacks: 0, wins: 0, territory: 0 };\n    const aggression = this.stats.aggression;\n    const evaluateMove = (from, to) => {\n        const diff = from.dice - to.dice;\n        const winProb = api.getWinProbability(from.dice, to.dice, api.diceSides);\n        const threshold = 0.6 - aggression * 0.3;\n        if (winProb < threshold) return -1;\n        let score = winProb * 100 + diff * 10;\n        if (from.dice === api.maxDice) score += 50;\n        if (to.dice === 1) score += 30 * aggression;\n        const neighbors = api.getAdjacentTiles(to.x, to.y);\n        const enemyNeighbors = neighbors.filter(n => n.owner !== api.myId).length;\n        score += enemyNeighbors * 10 * aggression;\n        return score;\n    };\n    const moves = [];\n    const attackers = api.getMyTiles().filter(t => t.dice > 1);\n    for (const tile of attackers) {\n        const neighbors = api.getAdjacentTiles(tile.x, tile.y);\n        for (const target of neighbors) {\n            if (target.owner !== api.myId) {\n                const score = evaluateMove(tile, target);\n                if (score > 0) moves.push({ from: tile, to: target, score });\n            }\n        }\n    }\n    moves.sort((a, b) => b.score - a.score);\n    const maxAttacks = Math.floor(5 + aggression * 20);\n    let attackCount = 0;\n    for (const move of moves) {\n        if (attackCount >= maxAttacks) break;\n        const currentTile = api.getTileAt(move.from.x, move.from.y);\n        if (currentTile && currentTile.dice > 1 && currentTile.owner === api.myId) {\n            const result = api.attack(move.from.x, move.from.y, move.to.x, move.to.y);\n            if (result.success) {\n                gameStats.attacks++;\n                if (result.expectedWin) gameStats.wins++;\n                attackCount++;\n            }\n        }\n    }\n    const currentTerritory = api.getMyTiles().length;\n    if (gameStats.territory === 0) gameStats.territory = currentTerritory;\n    else {\n        if (currentTerritory > gameStats.territory) this.stats.aggression = Math.min(1, this.stats.aggression + 0.02);\n        else if (currentTerritory < gameStats.territory) this.stats.aggression = Math.max(0.1, this.stats.aggression - 0.01);\n        gameStats.territory = currentTerritory;\n    }\n    api.save('stats', this.stats);\n    api.save('currentGame', gameStats);\n  }\n}"
    }
]