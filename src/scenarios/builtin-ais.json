[
    {
        "name": "Easy",
        "description": "Simple AI that attacks the weakest neighbors until it reaches its aggression quota.",
        "prompt": "",
        "code": "return class EasyAI {\n  async endTurn(api) {\n    const allMyTiles = api.getMyTiles();\n    const minAttacks = Math.ceil(allMyTiles.length * 0.2);\n    let attacksDone = 0;\n    let safety = 0;\n\n    while (safety < 500) {\n      safety++;\n      const attackers = api.getMyTiles().filter(t => t.dice > 1);\n      const moves = [];\n      \n      for (const tile of attackers) {\n        const neighbors = api.getAdjacentTiles(tile.x, tile.y);\n        for (const target of neighbors) {\n          if (target.owner !== api.myId) {\n            // Easy: Score by WEAKEST neighbor (least dice)\n            const score = -target.dice;\n            moves.push({ from: tile, to: target, score });\n          }\n        }\n      }\n\n      if (moves.length === 0) break;\n      moves.sort((a, b) => b.score - a.score);\n      \n      const move = moves[0];\n      // Proceed if below quota or if we have something to attack (Easy is simple)\n      if (attacksDone < minAttacks || moves.length > 0) {\n        // For Easy, after quota we might want to stop if it's too risky, \n        // but user says: \"find weakest... attack it. proceed again until minAttacks is reached\"\n        // So we stop after minAttacks.\n        const res = api.attack(move.from.x, move.from.y, move.to.x, move.to.y);\n        if (res.success) attacksDone++;\n        else break;\n\n        if (attacksDone >= minAttacks) break;\n      } else {\n        break;\n      }\n    }\n  }\n}"
    },
    {
        "name": "Medium",
        "description": "Tactical AI that targets strong neighbors it can likely defeat.",
        "prompt": "",
        "code": "return class MediumAI {\n  async endTurn(api) {\n    const allMyTiles = api.getMyTiles();\n    const minAttacks = Math.ceil(allMyTiles.length * 0.2);\n    let attacksDone = 0;\n    let safety = 0;\n\n    while (safety < 500) {\n      safety++;\n      const attackers = api.getMyTiles().filter(t => t.dice > 1);\n      const moves = [];\n      \n      for (const tile of attackers) {\n        const neighbors = api.getAdjacentTiles(tile.x, tile.y);\n        for (const target of neighbors) {\n          if (target.owner !== api.myId) {\n            const diff = tile.dice - target.dice;\n            let priority = 0;\n            \n            if (tile.dice < 4) {\n              if (diff === 1) priority = 5;      // High aggression for small stacks\n              else if (diff === 2) priority = 4;\n              else if (diff > 2) priority = 2;\n              else if (diff === 0) priority = 1;\n            } else {\n              if (diff === 2) priority = 4;      // Optimal stable margin\n              else if (diff === 1) priority = 3; // Efficient but riskier\n              else if (diff > 2) priority = 2;   // Overkill\n              else if (diff === 0) priority = 1; // Last resort flip\n            }\n            \n            if (priority > 0) {\n              // Score by strongest neighbor within priority\n              const score = (priority * 100) + target.dice;\n              moves.push({ from: tile, to: target, score });\n            }\n          }\n        }\n      }\n\n      if (moves.length === 0) break;\n      moves.sort((a, b) => b.score - a.score);\n      \n      const move = moves[0];\n      const res = api.attack(move.from.x, move.from.y, move.to.x, move.to.y);\n      if (res.success) attacksDone++;\n      else break;\n\n      if (attacksDone >= minAttacks) break;\n    }\n  }\n}"
    },
    {
        "name": "Hard",
        "description": "Strategic AI that optimizes every attack for maximum efficiency and position.",
        "prompt": "",
        "code": "return class HardAI {\n  async endTurn(api) {\n    const allMyTiles = api.getMyTiles();\n    const minAttacks = Math.ceil(allMyTiles.length * 0.2);\n    let attacksDone = 0;\n    let safety = 0;\n\n    while (safety < 500) {\n      safety++;\n      const attackers = api.getMyTiles().filter(t => t.dice > 1);\n      const moves = [];\n      \n      for (const tile of attackers) {\n        const neighbors = api.getAdjacentTiles(tile.x, tile.y);\n        for (const target of neighbors) {\n          if (target.owner !== api.myId) {\n            let priority = 0;\n            if (target.dice < tile.dice) priority = 2; // Better\n            else if (target.dice === tile.dice) priority = 1; // Equal\n            \n            if (priority > 0) {\n              // Score by strongest neighbor within priority\n              const score = (priority * 100) + target.dice;\n              moves.push({ from: tile, to: target, score });\n            }\n          }\n        }\n      }\n\n      if (moves.length === 0) break;\n      moves.sort((a, b) => b.score - a.score);\n      \n      const move = moves[0];\n      const res = api.attack(move.from.x, move.from.y, move.to.x, move.to.y);\n      if (res.success) attacksDone++;\n      else break;\n\n      if (attacksDone >= minAttacks) break;\n    }\n  }\n}"
    }
]